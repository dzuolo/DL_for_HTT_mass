#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import DL_for_HTT.common.NN_settings as NN_default_settings

from optparse import OptionParser
usage = "usage: %prog [options] <input>"
parser = OptionParser(usage=usage)
parser.add_option("-o", "--output", dest = "output",
                  default = "XGB")
parser.add_option("-m", "--minmass", dest = "min_mass",
                  default = NN_default_settings.min_mass)
parser.add_option("-M", "--maxmass", dest = "max_mass",
                  default = NN_default_settings.max_mass)
parser.add_option("-c", "--channels", dest = "channels",
                  default = NN_default_settings.channels)
parser.add_option("-d", "--max_depth", dest = "max_depth",
                  default = 10)
parser.add_option("-e", "--eta", dest = "eta",
                  default = 0.1)
parser.add_option("-r", "--num_round", dest = "num_round",
                  default = 20)

(options,args) = parser.parse_args()

min_mass = float(options.min_mass)
max_mass = float(options.max_mass)
options.max_depth = int(options.max_depth)
options.eta = float(options.eta)
options.num_round = int(options.num_round)

input_file = args[0]

print("Selected options are the following:")
for option in ["output", "min_mass", "max_mass"]:
    print("\t{}\t{}".format(option, getattr(options, option)))

print("Input file:")
print("\t{}".format(input_file))

import xgboost as xgb
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import pandas as pd
import tensorflow.keras as keras

# Load data
import os
df = pd.read_hdf(input_file)

# define target and input variables
target = NN_default_settings.target

print("Target: {}".format(target))

inputs = NN_default_settings.inputs

print("Inputs:")
for i in inputs:
    print("\t{}".format(i))

def XGB_make_train_predict(df, inputs, channel = "inclusive", max_depth = options.max_depth, eta = options.eta, num_round = options.num_round):

    param = {'max_depth' : max_depth, 'eta' : eta}
    # param = {'max_depth' : 20, 'eta' : 0.1}
    # num_round = 20

    XGBname = "-".join([options.output, channel, 'max_depth', str(param['max_depth']), 'eta', str(param['eta']), 'num_round', str(num_round)])

    print(XGBname)

    df_select = df

    df_select = df_select.loc[(df_select[target] >= min_mass) & (df_select[target] <= max_mass)]

    if channel in set(df_select['channel_reco']):
        df_select = df_select.loc[(df_select['channel_reco'] == channel)]
    elif channel == "lt":
        df_select = df_select.loc[(df_select['channel_reco'] == "mt") | (df_select['channel_reco'] == "et")]
    elif channel == "ll":
        df_select = df_select.loc[(df_select['channel_reco'] == "mm") | (df_select['channel_reco'] == "em") | (df_select['channel_reco'] == "ee")]

    df_x_train = df_select.loc[(df_select['is_train'] == 1), inputs]
    df_y_train = df_select.loc[(df_select['is_train'] == 1), [target]]
    df_x_valid = df_select.loc[(df_select['is_valid'] == 1), inputs]
    df_y_valid = df_select.loc[(df_select['is_valid'] == 1), [target]]
    df_x_test = df_select.loc[(df_select['is_test'] == 1), inputs]
    df_y_test = df_select.loc[(df_select['is_test'] == 1), [target]]

    print('Size of training set: ', len(df_x_train))
    print('Size of valid set: ', len(df_x_valid))

    if len(df_x_train) == 0 or len(df_x_valid) == 0:
        print("Empty set, aborting...")
        return None, False

    arr_x_train = np.r_[df_x_train]
    arr_y_train = np.r_[df_y_train[target]]
    arr_x_valid = np.r_[df_x_valid]
    arr_y_valid = np.r_[df_y_valid[target]]
    arr_x_test = np.r_[df_x_test]
    arr_y_test = np.r_[df_y_test[target]]

    # Create XGBoost Dmatrix
    DM_train = xgb.DMatrix(data = df_x_train, label = df_y_train, feature_names=inputs)
    DM_valid = xgb.DMatrix(data = df_x_valid, label = df_y_valid, feature_names=inputs)
    DM_test = xgb.DMatrix(data = df_x_test, label = df_y_test, feature_names=inputs)
    
    # Train XGB
    XGB = xgb.train(param, DM_train, num_round)

    # Save model
    XGB.save_model("XGB-{}.json".format(XGBname))

allowed_channels = ["inclusive", "tt", "mt", "et", "mm", "em", "ee", "lt", "ll"]

for channel in [c for c in options.channels.split(",") if c in allowed_channels]:
    XGB_make_train_predict(df, inputs, channel = channel)
