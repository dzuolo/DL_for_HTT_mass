#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import pandas as pd

import DL_for_HTT.post_training.utils as utils

from argparse import ArgumentParser
usage = "usage: prog [options]"
parser = ArgumentParser(usage=usage)
parser.add_argument("--basedir", default="/data2/ltorterotot/ML/", type=str, help="Directory in which looking for perf files")
parser.add_argument("--filters_to_match", default="trained,DeepTau,inclusive", type=str, help="Positive filterings, comma separated")
parser.add_argument("--filters_to_not_match", default="selected,1TeV,xyz,SGD", type=str, help="Negative filterings, comma separated")
parser.add_argument("--database_path", default="/data2/ltorterotot/ML/global_comparisons/", type=str, help="Path to database and plots")
parser.add_argument("--database_name", default="data_on_models", type=str, help="h5 database name to use.")
parser.add_argument("--update_database", action="store_true", help="Update already existing database")
parser.add_argument("--language", default = "fr")


args = parser.parse_args()

available_languages = ["fr", "en"]
if args.language not in available_languages:
    raise NotImplementedError ("Language {} not available. Possibles are: {}".format(args.language, ", ".join(available_languages)))

os.system("mkdir -p {}".format(args.database_path))
update_database = args.update_database
database_exists = int(
    os.popen(
        "if [ -e {}/{}.h5 ] ; then echo 1 ; else echo 0 ; fi".format(
            args.database_path,
            args.database_name
        )
    ).readlines()[0][:-1])

if update_database or database_exists == 0:
    if database_exists == 0:
        print("Create database...")
    else:
        print("Update database...")
    utils.create_scores_database(args)

print("Read database...")
df = pd.read_hdf("{}/{}.h5".format(args.database_path, args.database_name))

import locale
import matplotlib.pyplot as plt
plt.rcdefaults()
import numpy as np

plt.rcParams["figure.figsize"] = [7, 7]
plt.rcParams['axes.formatter.use_locale'] = True

def compare(
        df = df,
        variable = "full_mape",
        variable_exponent_factor = 0,
        global_filters = [],
        groups = [["type", "DNN", "DNN"], ["type", "XGB", "XGB"]],
        binning = 100,
        name = None,
        density = True,
):

    local_df = df.loc[df["type"] != "unknown"]
    for global_filter in global_filters:
        if global_filter[-1] == "r":
            local_df = local_df.loc[local_df[global_filter[0]] != global_filter[1]]
        else:
            local_df = local_df.loc[local_df[global_filter[0]] == global_filter[1]]

    if name == None:
        name = variable
    fig, ax = plt.subplots()

    for group in groups:
        if group[-1] == "r":
            values = local_df.loc[local_df[group[0]] != group[1]][variable] * 10**variable_exponent_factor
        else:
            values = local_df.loc[local_df[group[0]] == group[1]][variable] * 10**variable_exponent_factor
        n, bins, patches = ax.hist(
            values,
            binning,
            label = group[2],
            density = density,
            histtype = "step", linewidth=2,
        )

    ax.legend()
    ax.set_xlabel("{}{}".format(variable, r' $\times 10^{}$'.format(variable_exponent_factor) if variable_exponent_factor != 0 else ""))
    ax.set_ylabel("Densit√©")
    try:
        plt.xlim(binning[0], binning[-1])
    except:
        print("Not fixing xlims.")
    plt.savefig("{}/{}-{}.png".format(args.database_path, name, variable))
    plt.close()

def compare2d(
        df = df,
        variable = "full_mape",
        x = ["Nlayers", range(2,7)],
        y = ["Nneurons", [k*100 for k in range(2, 20)]],
        global_filters = [],
        name = "2d",
        density = True,
        extent = None,
        cmap_range = [None, None],
):

    local_df = df.loc[df["type"] != "unknown"]
    for global_filter in global_filters:
        if global_filter[-1] == "r":
            local_df = local_df.loc[local_df[global_filter[0]] != global_filter[1]]
        else:
            local_df = local_df.loc[local_df[global_filter[0]] == global_filter[1]]
            

    if name == None:
        name = variable
    fig, ax = plt.subplots()

    xs, ys = np.meshgrid(x[1], y[1])
    zs = 0.0* (xs+ys)
    for i1 in range(len(zs)):
        local_df2 = local_df.loc[(local_df[y[0]] == y[1][i1])]
        for i2 in range(len(zs[i1])):
            local_df3 = local_df2.loc[(local_df2[x[0]] == x[1][i2])]
            values = list(local_df3[variable].array[local_df3[variable].notna()])
            values.sort()
            values = values[:int(len(values)/2+1)]
            zs[i1][i2] = np.mean(values)
    zs[np.isnan(zs)] = zs.max()

    img = ax.imshow(
        zs,
        extent = extent,
        aspect='auto',
        origin='lower',
        cmap='RdYlGn_r',
        vmin = cmap_range[0], vmax = cmap_range[1],
    )

    clb = plt.colorbar(img, ax = ax)
    clb.ax.set_title(variable)
    
    ax.set_xlabel(x[0])
    ax.set_ylabel(y[0])
    plt.savefig("{}/{}-{}.png".format(args.database_path, name, variable))
    plt.close()

variables_base = ["mse", "mae", "mape", "median_diff", "1sig_width", "2sig_width", "1sig_calibr_width", "2sig_calibr_width"]
variables = []
for mass_region in ["low", "medium", "high", "full"]:
    variables += ["{}_{}".format(mass_region, variable) for variable in variables_base]

CURRENT_MODEL_FILTERS = []

compare(
    variable = "full_mse",
    groups = [
        ["type", "DNN", "DNN"],
        ["type", "XGB", "XGB"],
    ],
    binning = np.linspace(0,0.3,100),
    name = "DNN_vs_XGB",
)
compare(
    variable = "full_mae",
    variable_exponent_factor = 3,
        groups = [
        ["type", "DNN", "DNN"],
        ["type", "XGB", "XGB"],
        ],
    binning = np.linspace(0,2,100),
    name = "DNN_vs_XGB",
)
compare(
    variable = "full_mape",
    variable_exponent_factor = 3,
    groups = [
        ["type", "DNN", "DNN"],
        ["type", "XGB", "XGB"],
    ],
    binning = np.linspace(0,1,100),
    name = "DNN_vs_XGB",
)
compare(
    variable = "full_mape",
    variable_exponent_factor = 4,
    global_filters = [["type", "DNN", "DNN"]],
    groups = [
        ["model_inputs", "PuppiMET_with_METcov_j1j2jr_Nnu_Npu", "All inputs"],
        ["model_inputs", "PuppiMET_with_METcov_j1j2jr_Nnu_Npu", "Other inputs sets", "r"],
    ],
    binning = np.linspace(1,4,100),
    name = "DNN_inputs",
)
compare(
    variable = "full_1sig_width",
    global_filters = [["type", "DNN", "DNN"]],
    groups = [
        ["model_inputs", "PuppiMET_with_METcov_j1j2jr_Nnu_Npu", "All inputs"],
        ["model_inputs", "PuppiMET_with_METcov_j1j2jr_Nnu_Npu", "Other inputs sets", "r"],
    ],
    binning = np.linspace(3,10,100),
    name = "DNN_inputs",
)
compare(
    variable = "full_mape",
    variable_exponent_factor = 3,
    global_filters = [["type", "XGB", "XGB"]],
    groups = [
        ["model_inputs", "PuppiMET_with_METcov_j1j2jr_Nnu_Npu", "All inputs"],
        ["model_inputs", "PuppiMET_with_METcov_j1j2jr_Nnu_Npu", "Other inputs sets", "r"],
    ],
    binning = np.linspace(0,1,100),
    name = "XGB_inputs",
)
compare(
    variable = "full_1sig_width",
    global_filters = [["type", "XGB", "XGB"]],
    groups = [
        ["model_inputs", "PuppiMET_with_METcov_j1j2jr_Nnu_Npu", "All inputs"],
        ["model_inputs", "PuppiMET_with_METcov_j1j2jr_Nnu_Npu", "Other inputs sets", "r"],
    ],
    binning = np.linspace(0,8,100),
    name = "XGB_inputs",
)

CURRENT_MODEL_FILTERS.append(["type", "DNN", "DNN"])
CURRENT_MODEL_FILTERS.append(["model_inputs", "PuppiMET_with_METcov_j1j2jr_Nnu_Npu", "All inputs"])

losses = list(set(df.loc[df.type == "DNN"]["loss"]))
losses.sort()
losses = ["mape", "mse"]
compare(
    variable = "full_mape",
    variable_exponent_factor = 4,
    global_filters = CURRENT_MODEL_FILTERS,
    groups = [
        ["loss", loss, loss] for loss in losses
    ],
    binning = np.linspace(1,5,100),
    name = "DNN_loss",
)
compare(
    variable = "full_mse",
    global_filters = CURRENT_MODEL_FILTERS,
    groups = [
        ["loss", loss, loss] for loss in losses
    ],
    binning = np.linspace(0,0.3,100),
    name = "DNN_loss",
)
compare(
    variable = "full_mae",
    variable_exponent_factor = 3,
    global_filters = CURRENT_MODEL_FILTERS,
    groups = [
        ["loss", loss, loss] for loss in losses
    ],
    binning = np.linspace(0.5,1,100),
    name = "DNN_loss",
)
compare(
        variable = "full_median_diff",
    global_filters = CURRENT_MODEL_FILTERS,
    groups = [
        ["loss", loss, loss] for loss in losses
    ],
    binning = np.linspace(0,4,100),
    name = "DNN_loss",
)

CURRENT_MODEL_FILTERS.append(["loss", "mape"])

compare(
    variable = "full_mape",
    variable_exponent_factor = 4,
    global_filters = CURRENT_MODEL_FILTERS,
    groups = [
        ["optimizer", opt, opt] for opt in ["Adam", "Adadelta"]
    ],
    binning = np.linspace(1,3,100),
    name = "DNN_optimizer",
)

CURRENT_MODEL_FILTERS.append(["optimizer", "Adam"])

compare(
    variable = "full_mape",
    variable_exponent_factor = 4,
    global_filters = CURRENT_MODEL_FILTERS,
    groups = [
        ["w_init_mode", wi, wi] for wi in ["gu", "gn", "u", "n"]
    ],
    binning = np.linspace(1.5,2,100),
    name = "DNN_w_init_mode",
)

CURRENT_MODEL_FILTERS.append(["w_init_mode", "gu"])

compare(
    variable = "full_mape",
    variable_exponent_factor = 4,
    global_filters = CURRENT_MODEL_FILTERS,
    groups = [
        ["Nlayers", k, "{} hidden layers".format(k)] for k in range (2, 6)
    ],
    binning = np.linspace(1.5,2,100),
    name = "DNN_N_layers",
)
compare(
    variable = "full_mape",
    variable_exponent_factor = 4,
    global_filters = CURRENT_MODEL_FILTERS,
    groups = [
        ["Nneurons", k*100, "{} neurons".format(int(k*100))] for k in [2, 4, 6, 10, 14, 16]
    ],
    binning = np.linspace(1.5,2,100),
    name = "DNN_N_neurons",
)
cmap_range = {
    "DNN_structures_all" : {
        "full_mape" : [0.000160, 0.000175],
        "full_median_diff" : [1.5, 2.0],
        "full_1sig_width" : [5.5, 6.5],
        "full_1sig_calibr_width" : [5.5, 6.5],
        "low_mape" : [0.009, 0.011],
        "low_median_diff" : [0.06, 0.25],
        "low_1sig_width" : [0.875, 0.975],
        "low_1sig_calibr_width" : [0.875, 0.975],
    },
}
cmap_range["DNN_structures_reduced"] = cmap_range["DNN_structures_all"]
cmap_range["XGB_structures"] = cmap_range["DNN_structures_all"]
for variable in ["full_mape", "full_median_diff", "full_1sig_width", "full_1sig_calibr_width", "low_mape", "low_median_diff", "low_1sig_width", "low_1sig_calibr_width"]:
    compare2d(
        variable = variable,
        x = ["Nlayers", range(2,7)],
        y = ["Nneurons", [k*100 for k in range(2, 21)]],
        extent = (1.5, 6.5, 150, 2050),
        global_filters = CURRENT_MODEL_FILTERS,
        name = "DNN_structures_all",
        cmap_range = cmap_range["DNN_structures_all"][variable],
    )
    compare2d(
        variable = variable,
        x = ["Nlayers", range(2,7)],
        y = ["Nneurons", [k*100 for k in range(2, 15, 4)]],
        extent = (1.5, 6.5, 0, 1600),
        global_filters = CURRENT_MODEL_FILTERS,
        name = "DNN_structures_reduced",
        cmap_range = cmap_range["DNN_structures_reduced"][variable],
    )
    compare2d(
        variable = variable,
        x = ["max_depth", range(1,11)],
        y = ["eta", [k/100 for k in range(5, 51, 5)]],
        extent = (0.5, 10.5, 0.025, 0.525),
        global_filters = [["type", "XGB", "XGB"], ["model_inputs", "PuppiMET_with_METcov_j1j2jr_Nnu_Npu", "All inputs"]],
        name = "XGB_structures",
        cmap_range = cmap_range["XGB_structures"][variable],
    )
#import pdb; pdb.set_trace()
